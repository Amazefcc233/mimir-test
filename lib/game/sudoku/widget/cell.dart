import 'package:flutter/material.dart';
import 'package:rettulf/rettulf.dart';

import '../utils.dart';

class CellNotes extends StatelessWidget {
  final Set<int> notes;
  final bool cellSelected;

  const CellNotes({
    super.key,
    required this.notes,
    this.cellSelected = false,
  });

  @override
  Widget build(BuildContext context) {
    return GridView.builder(
      padding: EdgeInsets.zero,
      physics: NeverScrollableScrollPhysics(),
      itemCount: 9,
      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 3),
      itemBuilder: (BuildContext context, int index) {
        final number = index + 1;
        final notedThis = notes.contains(number);
        return Text(
          notedThis ? "${number}" : "",
          textAlign: TextAlign.center,
          style: TextStyle(
            color: cellSelected ? context.colorScheme.onPrimaryContainer : context.colorScheme.onSurfaceVariant,
            fontSize: 12,
          ),
        );
      },
    );
  }
}

class SudokuCell {
  /// A negative value (e.g., -1) indicates a pre-filled cell generated by the puzzle.
  /// The user cannot modify this value.
  /// `0` means the cell is empty and awaits user input.
  final int userInput;

  /// The correct value that the user should fill in the cell (1 to 9).
  final int correctValue;

  const SudokuCell({
    this.userInput = -1,
    this.correctValue = 0,
  }) : assert(correctValue == 0 || (1 <= correctValue && correctValue <= 9),
            "The puzzle should generate correct value in [1,9] but $correctValue");

  bool get isPuzzle => userInput < 0;

  bool get canUserInput => userInput >= 0;

  bool get emptyInput {
    assert(userInput >= 0, "Developer should check `isPuzzle` before access this");
    return userInput == 0;
  }

  bool get isSolved {
    assert(userInput >= 0, "Developer should check `isPuzzle` before access this");
    return userInput == correctValue;
  }

  @override
  bool operator ==(Object other) {
    return other is SudokuCell &&
        runtimeType == other.runtimeType &&
        userInput == other.userInput &&
        correctValue == other.correctValue;
  }

  @override
  int get hashCode => Object.hash(userInput, correctValue);
}

class CellNumber extends StatelessWidget {
  final SudokuCell cell;

  CellNumber({
    required int userInput,
    required int correctValue,
  }) : this._(cell: SudokuCell(userInput: userInput, correctValue: correctValue));

  const CellNumber._({
    super.key,
    required this.cell,
  });

  @override
  Widget build(BuildContext context) {
    return Text(
      cell.isPuzzle ? "${cell.correctValue}" : (cell.emptyInput ? "" : "${cell.userInput}"),
      textAlign: TextAlign.center,
      style: TextStyle(
        fontSize: 25,
        fontWeight: cell.isPuzzle ? FontWeight.w800 : FontWeight.normal,
        color: cell.isPuzzle
            ? context.colorScheme.onSurfaceVariant.withOpacity(0.5)
            : cell.isSolved
                ? context.colorScheme.onPrimaryContainer
                : Colors.red,
      ),
    );
  }
}

class CellWidget extends StatelessWidget {
  final int index;
  final int selectedIndex;
  final VoidCallback onTap;
  final Widget child;

  const CellWidget({
    super.key,
    required this.index,
    required this.onTap,
    required this.selectedIndex,
    required this.child,
  });

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: onTap,
      child: Container(
        alignment: Alignment.center,
        decoration: BoxDecoration(
          color: getCellBgColor(
            index: index,
            selectedIndex: selectedIndex,
            context: context,
          ),
          border: Border.all(color: context.colorScheme.onBackground),
        ),
        child: child,
      ),
    );
  }
}
